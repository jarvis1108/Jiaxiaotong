package com.dxtwangxiao.strongestsuperscholar.web.websocket.match;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.dxtwangxiao.strongestsuperscholar.module.system.entity.UserRelInfo;
import com.dxtwangxiao.strongestsuperscholar.module.system.service.UserRelInfoService;
import com.dxtwangxiao.strongestsuperscholar.module.system.service.UserService;
import com.dxtwangxiao.strongestsuperscholar.web.dto.MatchRecordDTO;
import com.dxtwangxiao.strongestsuperscholar.module.question.vo.MultipleQuestion;
import com.dxtwangxiao.strongestsuperscholar.web.dto.UserDTO;
import com.dxtwangxiao.strongestsuperscholar.web.vo.ResultData;
import com.dxtwangxiao.strongestsuperscholar.web.websocket.common.MatchManagement;
import com.dxtwangxiao.strongestsuperscholar.web.websocket.common.Message;
import org.springframework.context.ApplicationContext;
import org.springframework.web.socket.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * 匹配对战 WebSocket处理类，真正的匹配及出题业务逻辑在此
 * <p>
 * Created by Devin
 * 2018-07-25 下午 03:10
 */
public class MatchWebSocketHandler implements WebSocketHandler {

	// 启动类set方法注入，解决无法注入Bean的问题
	private static ApplicationContext applicationContext;

	public static void setApplicationContext(ApplicationContext context) {
		applicationContext = context;
	}

	private static final Map<String, WebSocketSession> users;    // 用户列表
	private static final Map<Integer, Queue<UserDTO>> matchPool; // 匹配池

	static {
		users = new ConcurrentHashMap<>();

		Queue<UserDTO> firstLevelQueue = new LinkedBlockingQueue<>();
		Queue<UserDTO> secondLevelQueue = new LinkedBlockingQueue<>();
		Queue<UserDTO> thirdLevelQueue = new LinkedBlockingQueue<>();
		Queue<UserDTO> fourthLevelQueue = new LinkedBlockingQueue<>();
		matchPool = new ConcurrentHashMap<>();
		matchPool.put(1, firstLevelQueue);
		matchPool.put(2, secondLevelQueue);
		matchPool.put(3, thirdLevelQueue);
		matchPool.put(4, fourthLevelQueue);
	}

	/**
	 * 新增socket，实际上就是建立了一个新的连接
	 * 连接建立后，处理业务逻辑
	 *
	 * @param session
	 */
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		// 1.从session中获取当前用户ID
		String userId = (String) session.getAttributes().get("MATCH_USER_ID");

		// 2.根据用户ID获取其信息
		UserService userService = applicationContext.getBean(UserService.class);
		UserDTO userDTO = userService.getUserDTOById(userId);

		// 3. 如果用户存在，则将其加入到在线用户列表
		if (userDTO != null) {
			users.put(userId, session);
		} else {
			return;
		}

		// 4.开始匹配
		Queue<UserDTO> queue = matchPool.get(userDTO.getInternalLevel());
		if (queue.isEmpty()) {
			queue.offer(userDTO);
		} else {
			// (1)匹配成功，将对手移除队列
			UserDTO opponent = queue.poll();

			// (2)创建战局记录，并将用户及对手加入到战局中
			MatchRecordDTO matchRecordDTO = MatchManagement.getInstance().createMatchRecord(userId, Byte.valueOf("0"));
			MatchManagement.getInstance().addUser(matchRecordDTO.getMatchRecordId(), userDTO, Byte.valueOf("1"));
			MatchManagement.getInstance().addUser(matchRecordDTO.getMatchRecordId(), opponent, Byte.valueOf("0"));

			// (3)向客户端发送消息，表明匹配成功
			Message result = new Message();
			result.setMsgType("A");
			result.setMsgDesc("匹配成功");
			result.setMsgID(UUID.randomUUID().toString());
			Map<String, Object> curData = new HashMap<>();
			curData.put("opponent", opponent);
			curData.put("matchId", matchRecordDTO.getMatchRecordId());
			result.setMsgData(new ResultData(curData));
			sendMessageToUser(userId, new TextMessage(JSON.toJSONString(result)));

			// (4)向对手发送消息，表明匹配成功
			curData.replace("opponent", userDTO);
			sendMessageToUser(opponent.getUserId(), new TextMessage(JSON.toJSONString(result)));
		}
	}

	@Override
	public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception {
		String userId = (String) session.getAttributes().get("MATCH_USER_ID");

		JSONObject jsonObject = JSON.parseObject(message.getPayload().toString());
		String msgType = jsonObject.getString("msgType");
		JSONObject msgData = jsonObject.getJSONObject("msgData");

		if (msgType.equals("A")) {
			// 消息类型为A时，表示客户端请求出题，根据试题索引，获取战局记录
			String matchId = msgData.getString("matchId");
			Integer no = msgData.getInteger("no");

			// (1)根据战局ID获取战局记录，进而获取战局题目
			MatchRecordDTO match = MatchManagement.getInstance().getMatchByMatchId(matchId);
			MultipleQuestion multipleQuestion = match.getQuestionList().get(no - 1);

			// (2)向客户端发送消息，表明出题成功
			Message result = new Message();
			result.setMsgID(UUID.randomUUID().toString());
			result.setMsgType("B");
			Map<String, Object> curData = new HashMap<>();
			curData.put("question", multipleQuestion);
			result.setMsgData(new ResultData(curData));
			result.setMsgDesc("出题成功");
			sendMessageToUser(userId, new TextMessage(JSON.toJSONString(result)));
		}

		if (msgType.equals("B")) {
			// 客户端请求计算该题分数，并返回给客户端和对手
			String matchId = msgData.getString("matchId");
			String correctAnswer = msgData.getString("correctAnswer");
			String userAnswer = msgData.getString("userAnswer");
			Integer timeLeft = msgData.getInteger("timeLeft");
			Integer questionIndex = msgData.getInteger("no");

			// 存储用户学点消耗到数据库
			Integer amount = 10 - timeLeft;
			Byte isTrue;
			if (userAnswer.equals(correctAnswer)) {
				isTrue = Byte.valueOf("1");
			} else {
				isTrue = Byte.valueOf("0");
			}
			MatchManagement.getInstance().saveLpConsumeRecord(matchId, userId, questionIndex, userAnswer, amount, isTrue);

			// 计算分数
			int score;
			if (correctAnswer.equals(userAnswer)) {
				score = timeLeft * (200 / 10);
			} else {
				score = 0;
			}

			// 向客户端发送消息
			Message result = new Message();
			result.setMsgID(UUID.randomUUID().toString());
			result.setMsgType("C-1");
			Map<String, Object> curData = new HashMap<>();
			curData.put("score", score);
			result.setMsgData(new ResultData(curData));
			result.setMsgDesc("发送给客户端的成绩");
			sendMessageToUser(userId, new TextMessage(JSON.toJSONString(result)));

			result.setMsgType("C-2");
			curData.put("answer", userAnswer);
			result.setMsgDesc("发送给对手的成绩");
			for (UserDTO userDTO : MatchManagement.getInstance().getMatchByMatchId(matchId).getUserList()) {
				String userDTOId = userDTO.getUserId();
				if (!userDTOId.equals(userId))
					sendMessageToUser(userDTOId, new TextMessage(JSON.toJSONString(result)));
			}
		}
	}

	@Override
	public void handleTransportError(WebSocketSession webSocketSession, Throwable throwable) throws Exception {

	}

	@Override
	public void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus closeStatus) throws Exception {
		System.out.println("在线用户数量：" + users.size());
		// (1) 如果用户在等待匹配，那么从用户列表和匹配池（如果存在）中删除用户
		String userId = (String) webSocketSession.getAttributes().get("MATCH_USER_ID");
		users.remove(userId);

		UserRelInfoService userRelInfoService = applicationContext.getBean(UserRelInfoService.class);
		UserRelInfo userRelInfo = userRelInfoService.getByUserId(userId);
		Queue<UserDTO> userDTOQueue = matchPool.get(userRelInfo.getInternalLevel());
		if (!userDTOQueue.isEmpty())
			userDTOQueue.remove();

		// (2) 如果用户在对战过程中失去连接，那么还要删除战局记录。
		MatchManagement.getInstance().removeMatchByUserId(userId);
		System.out.println("在线用户数量：" + users.size());
	}

	@Override
	public boolean supportsPartialMessages() {
		return false;
	}


	private boolean sendMessageToUser(String userID, TextMessage message) {
		if (users.get(userID) == null)
			return false;

		WebSocketSession session = users.get(userID);
		if (!session.isOpen())
			return false;

		try {
			session.sendMessage(message);
		} catch (IOException e) {
			e.printStackTrace();
			return false;
		}

		return true;
	}
}